<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        /**{*/
        /*    border: 1px solid;*/
        /*}*/
        body{
            font-family: Arial;
            font-size: 110%;
            max-width: 1000px;
            margin: auto    ;
            background-image: linear-gradient(to right, #c6ffdd, #fbd786, #f7797d);

        }



    </style>
</head>
<body>
<h1 style="text-align: center" id="top">Access modifier, static method, static property</h1>
<ol type="I">
    <h3><li><a href="#thamchieu">Tham trị và tham chiếu</a></li></h3>
    <h3><li><a href="#bien">Biến trong java</a></li></h3>
    <h3><li><a href="#acm">Access modifier</a></li></h3>
    <h3><li><a href="#get">Tính đóng gói (Encapsulation) - Getter/ Setter</a></li></h3>
    <h3><li><a href="#package">Package & Static method</a></li></h3>
    <h3><li><a href="#nested">Nested Class & Local Class</a></li></h3>
</ol>
<hr>
<pre id="thamchieu">
  <h3>Tham trị và tham chiếu</h3>
<b>1. Tham trị</b>
  -   Các biêến thuộc kiểu DL nguyên thủy: boolean, char, byte, short, int, long, float, double
  ==> lưu giá trị của chúng ở bộ nhớ STACK.
  -   Truyền giá trị của biến (không phải địa chỉ ô nhớ) ==> phương thức tạo ra địa chỉ ô nhớ mới
để lưu giá trị này ==> bên trong thay đổi, bên ngoài không đổi
<b>2. Tham chiếu</b>
  -   Các biến thuộc kiểu dữ liệu tham chiếu lưu trữ <b>tham chiếu</b> đến đối tượng (đối tượng được lưu trong bộ nhớ HEAP).
  -   Truyền địa chỉ ô nhớ ==> bên trong thay đổi thì bên ngoài thay đổi
</pre>
<hr>
<pre>
  <h3>Biến trong Java</h3>
  <b>1. Biến local (biến trong block code</b>
  -   Biến local được khai báo trong các phương thức, hàm contructor hoặc trong các block.
  -   Sẽ bị phá hủy khi kết thúc các phương thức, contructor và block.
  -   Không được sử dụng "access modifier" khi khai báo biến local.
  -   Các biến local được lưu trên vùng nhớ stack của bộ nhớ.
  -   Cần khởi tạo giá trị mặc định cho biến local trước khi có thể sử dụng.
  <b>2. Biến instance (biến toàn cục)</b>
  -   Biến instance được khai báo trong một lớp(class), bên ngoài các phương thức, constructor và các block.
  -   Biến instance được lưu trong bộ nhớ heap.
  -   Biến instance được tạo khi một đối tượng được tạo bằng việc sử dụng từ khóa “new” và sẽ bị phá hủy khi đối tượng bị phá hủy.
  -   Biến instance có thể được sử dụng bởi các phương thức, constructor, block, ... Nhưng nó phải được sử dụng thông qua một đối tượng cụ thể
  -   Bạn được phép sử dụng "access modifier" khi khai báo biến instance, mặc định là "default".
  -   Biến instance có giá trị mặc định phụ thuộc vào kiểu dữ liệu của nó. Ví dụ nếu là kiểu int, short, byte thì giá trị mặc định là 0, kiểu double thì là 0.0d, ...
  Vì vậy, bạn sẽ không cần khởi tạo giá trị cho biến instance trước khi sử dụng.
  -   Bên trong class mà bạn khai báo biến instance, bạn có thể gọi nó trực tiếp bằng tên khi sử dụng ở khắp nới bên trong class đó.
  <b>2. Biến static (biến của lớp)</b>
-   Biến static được khai báo trong một class với từ khóa "static", phía bên ngoài các phương thức, constructor và block.
-   Sẽ chỉ có duy nhất một bản sao của các biến static được tạo ra, dù bạn tạo bao nhiêu đối tượng từ lớp tương ứng.
-   Biến static được lưu trữ trong bộ nhớ static riêng.
-   Biến static được tạo khi chương trình bắt đầu chạy và chỉ bị phá hủy khi chương trình dừng.
-   Giá trị mặc định của biến static phụ thuộc vào kiểu dữ liệu bạn khai báo tương tự biến instance.
-   Biến static được truy cập thông qua tên của class chứa nó, với cú pháp: TenClass.tenBien.
-   Trong class, các phương thức sử dụng biến static bằng cách gọi tên của nó khi phương thức đó cũng được khai báo với từ khóa "static".
</pre>
<hr>
<pre id="acm">
  <h3>Access modifier</h3>
Access modifier là các từ khoá được sử dụng để quy định mức độ truy cập đến lớp và các thành phần của lớp
-   public: có thể truy cập từ bất cứ đâu;
-   private: các phương thức và thuộc tính chỉ được phép truy xuất trong cùng một lớp;
-   protected: các PT và thuộc tính được phép truy xuất trong cùng một lớp và ở các lớp con (kế thừa);
-   default: nếu không có access modifier thì mức default sẽ được áp dụng. Lớp và các thành phần của lớp
    được truy xuất ở những nơi trong cùng một package
-   <b>Local Variables và Access Modifiers</b>:
    +   Biến local được khai báo trong các phương thức, hàm contructor hoặc trong các block.
    +   không thể áp dụng access modifier cho các biến cục bộ
    +   chỉ áp dụng được modifier là <b>final</b>

</pre>
<div style="display: flex">
    <div style="width: 50%; height: 300px;">
        <div style="width: 100%;">Ví dụ:</div>
        <div style="width: 100%"><img src="https://i.imgur.com/4ILyBkC.png" alt="" width="100%" height="250px"></div>
    </div>
    <div style="width: 50%; height: 300px;">
        <div style="width: 100%;">Tổng hợp các mức truy cập</div>
        <div style="width: 100%"><img src="https://i.imgur.com/6w2YlYD.png" alt="" width="100%" height="250px"></div>
    </div>
</div>
<hr>
<pre id="get">
  <h3>Tính đóng gói (Encapsulation) - Getter/ Sette</h3>
-   Data field encapsulation (bao gói trường dữ liệu): hạn chế quyền truy cập trực tiếp vào các thuộc tính/ phương thức
của đối tượng bằng cách sử dụng từ khoá PRIVATE.
-   Khai báo các phương thức để kiểm soát việc truy cập vào các thuộc tính của đối tượng:
    Thay đổi giá trị của thuộc tính ==> setter: setName(), setAge(), ...
    Lấy về giá trị của thuộc tính ==> getterL getName(), getAge(), ...

    + getter:       public returnType getPropertyName(){}                //return this.property = property;
    + setter:       public void setPropertyName(dataType property){}    //this.property = property;
    + boolean:      public boolean isPropertyName(){}

-   this:   Đại diện cho đối tượng hiện tại
            Nếu muốn constructor nào đó gọi đến một constructor khác thì sử dụng this(tham số);
            Sử dụng this.field để phân biệt field với tham số của phương thức và các biến cục bộ khác
            Truy xuất tới các thành phần của đối tượng hiện tại

</pre>
<hr>
<pre>
    <h3 id="package">1. Package (gói)</h3>
    -   Là cách phân loại các lớp và interface thành các nhóm có liên quan đến nhau và tổ chức chúng thành các đơn vị để quản lý.
    -   java.io, java.net, java.security, java.util, ...
    -   Có thể tự định nghĩa các gói mới để tổ chức mã nguồn hợp lý
    <b>Tính chất của package</b>:
    -    Có thể khai báo các gói con -subpackage (gói trong gói)
    -    Không thể có 2 lớp cùng tên trong cùng 1 gói
    -    Khi 1 lớp được khai báo bên trong 1 gói thì cần sử dụng tên gói nếu muốn truy cập đến lớp đó
    -    Tên của gói được viết = chữ thường
    -    Các gói sẵn có của Java bắt đầu từ java hoặc javax

    <b>Khai báo</b>

    -   Cú pháp:
                <b>package</b> package_name;

    -   Ví dụ:  <b>package</b>  codegym;

    -   Tên package phải trùng với tên của thư mục chứa mã nguồn.

    -   Tên của subpackage phải lần lượt TRÙNG với eên của các thư mục tương ứng
    Ví dụ:  package com.codegym.ui: thư mục ui nằm trong thư mục codegym, codegym nằm trong thư mục com.

    -   Từ khoá <b>Import</b>: để sử dụng các lớp được định nghĩa trong các package khác

    -   Ví dụ: <br>
    <img src="https://i.imgur.com/7Cgqfo7.png" alt="" width="40%">
    <hr>
<h3>2. Static</h3>
    -   Từ khoá <b>static</b> dùng để khai báo các thuộc tính/ phương thức của lớp (khác của đối tượng)
    -   Các thành phần static TRỰC THUỘC LỚP thay vì trực thuộc đối tượng.
    -   Biến <b>static</b> còn gọi là biến của lớp (class variable).
    -   Phương thức <b>static</b> còn gọi là phương thức của lớp (class method).
    -   Có thể TRUY XUẤT các thành phần static bằng cách sử dụng lớp hoặc đối tượng.
    -   Không cần khởi tạo đối tượng vẫn có thể sử dụng các thành phần static.

    -   Cú pháp <b>static property</b>:

            <b>modifier</b> <b>static</b> data_type variable_name;

    -   Cú pháp <b>static method</b>:

            <b>modifier</b> <b>static</b> data_type method_name(){
                    //body;
            }
    Ví dụ:
            class MyClass{
                    public static String str = "Java";
                    public static String getNumber(){
                        return 1;
                    }

            }
    ==> truy xuất property: System.out.print(MyClass.str);
    ==> truy xuất method: System.out.print(MyClass.getNumber);

    -   MỘT SỐ RÀNG BUỘC:
        +   Phương thức <b>static</b>: có thể truy cập biến static và thay đổi giá trị của nó
                                     . chỉ có thể gọi các phương thức static khác, không thể gọi các phương thức nonstatic
                                     . chỉ có thể truy xuất các biến static, không thể truy xuất các biến instance (nonstatic)
                                     . không thể sử dụng <b>this/ super</b>
        +   Có thể khởi tạo biến static thông qua khối khởi tạo static <br>
    <img src="https://i.imgur.com/WWiSEJ1.png" alt="" width="30%">
  <hr>
  <h3 id="nested">Nested Class (lớp lồng nhau)</h3>

  - Là 1 lớp được khai báo trong lớp khác.

  - <b>Khi nào sử dụng Nested Class:</b>
    + Tạo ra 1 lớp có liên quan đến lớp bên ngoài mà không cần tạo 1 lớp mới.
    + Tăng tính bao gói (encapsulation) khi các thành phần của lớp bên trong chỉ được sử dụng bởi lớp bao nó.
    + Giúp mã nguồn dễ đọc, dễ bảo trì hơn.
  -   Nested class chia thành 2 loại:

<b>1. static (static nested class)</b>

-   Trực thuộc lớp bên ngoài (thay vì trực thuộc đối tượng của lớp bên ngoài.
-   không thể truy xuất đến các thành phần của lớp bên ngoài.
-   Sử dụng tên của lớp bên ngoài để truy cập đến lớp bên trong.
-   OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();

<b>2. non-static (Inner class)</b>

-   Trực thuộc 1 đối tượng của lớp bên ngoài.
-   Có thể truy xuất đến các thành phần của lớp bên ngoài.
-   Sử dụng tham chiếu của một đối tượng của lớp bên ngoài để truy xuất đến Inner class.
-   Có thể đặt <b>private/ protected</b>. Nếu không muốn các đối tượng bên ngoài truy cập vào bên trong thì có thể khai báo lớp đó là <b>private</b>

<b>3. Local class (lớp địa phương)</b>

-   Lớp được khai báo và sử dụng trong 1 khối lệnh.
-   Không thể sử dụng bên ngoài khối lệnh được khai báo.

<b>4. Anonymous class</b>
-   Là lớp đặc biệt được khai báo và khởi tạo đối tượng tại cùng 1 thời điểm
-   Anonymous class ần kế thừa 1 lớp hoặc triển khải 1 interface
<hr>


</pre>
<button style="position: fixed; bottom: 0; left: 0"><a href="#top">Go to Top</a></button>
</body>
</html>